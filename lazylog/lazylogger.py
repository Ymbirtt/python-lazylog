import logging

BaseLogger = logging.getLoggerClass()

class LazyLogger(BaseLogger):
    def debug(self, func, *args, **kwargs):
        """ Lazily logs at the debug level. See LazyLogger#log """
        self.log(logging.DEBUG, func, *args, **kwargs)

    def info(self, func, *args, **kwargs):
        """ Lazily logs at the info level. See LazyLogger#log """
        self.log(logging.INFO, func, *args, **kwargs)

    def warning(self, func, *args, **kwargs):
        """ Lazily logs at the warning level. See LazyLogger#log """
        self.log(logging.WARNING, func, *args, **kwargs)
    warn=warning

    def error(self, func, *args, **kwargs):
        """ Lazily logs at the error level. See LazyLogger#log """
        self.log(logging.ERROR, func, *args, **kwargs)

    def critical(self, func, *args, **kwargs):
        """ Lazily logs at the critical level. See LazyLogger#log """
        self.log(logging.CRITICAL, func, *args, **kwargs)
    fatal = critical

    def log(self, level, func, *args, **kwargs):
        """ Lazily log a message generated by func at the given level.
        If this logger is enabled for the given level, func will be called with no arguments and the base logger class will be passed its return value.
        If this logger is not enabled for the given level, func will not be called.
        If attempting to call func raises a TypeError, for instance, if it's actually a string, then func will
        be passed directly down to the base logger without being called
        """
        if self.isEnabledFor(level):
            try:
                msg = func()
            except TypeError:
                msg = func
            BaseLogger.log(self, level, msg, *args, **kwargs)

